Card Command Library for Maple (last modified on 4 Sep 2012)

Overview
========

The goal of this library is to provide an feature set of commands specific to
each card type. Thereby, a user can implement (at a minimum) read and writes
to a card's registers.

Reference Manual for STM32F103ZE:
http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/REFERENCE_MANUAL/CD00171190.pdf

SD Card Physical Layer Specification:
https://www.sdcard.org/downloads/pls/simplified_specs/Part_1_Physical_Layer_Simplified_Specification_Ver_3.01_Final_100518.pdf

Most of the work done to date has been to set up a C rountine API for users to 
initialize their own cards and interface with the SDIO peripheral. From this 
codebase, a C++ API will be developed for commonly used methods.
Thus far, the status of this library has beento idenitfy a card and read it's 
card specific registers.
This is known as the card initialization and identification process, and it is
complete and in the testing phase. The begin() function provides this process.


Functionality
=============

Currenly, the only functioning code is the initialization and identification 
process. This includes all the functions called from within these, like 
sending cmd8 and acmd41 for checking the interface conditions.

CID Number
----------

This process also reads the CID which includes data like the 
serial number and manufactur date. Other card specicfic data is read from the 
CSD which is also functional. Although, since I have no independent source 
from which to read these values to verify a proper read, much of this 
functionality is circumstantial; meaning that the values make some sense eg. 
the manufacture date is current and in the past.


Reading and Writing Blocks
--------------------------

First up is reading any block on the card, later writing will be tested. This 
is being done to protect the cards from immature code in the off chance that 
something is irrevocably damaged. 

Data is transferred on one or four data lines. I will focus on reading with 
only one data line to start, check that the fifo is working with interrupts, 
and then expand. The ultimate goal is to have data transferred over DMA, but 
but a polling scheme might be implemented for a slow speed demo.

Testing
-------

Here is an example of a command on OSX that reads the one-thousandth block of 
an SD card mounted as disk4, and writes the result out to a file:

dd if=/dev/disk4 of=test.bin bs=512 count=1 iseek=1000


Conflicts (to be conmplete)
=========

peripheral gpio pins in use
DMA2 Channel4
card detection pin


mapleFAT Proposal
=================

High-density performance line devices have one SDIO peripheral and up to three
SPI peripherals. This document seeks to explain the design specifications for 
a FAT filesystem on such devices. It will focus (for the moment) on a 
high-level description of the classes involved and their inheritance schemes.

Inheritance Structure
---------------------

           +-------------+                  +-------------+
           | SDMode-FAT  |                  | SPIMode-FAT |
           +-------------+                  +-------------+ high-level
                  |       \                /       |
                  |        \              /        |
                  |         \            /         |
                  |          +----------+          |
                  |          | mapleFAT |          |
                  |          +----------+ abstract |
                  |                                |
                  |                                |
           +--------------+                 +-------------+
           | HardwareSDIO |                 | HardwareSPI |
           +--------------+                 +-------------+ low-level

This diagram depicts the five proposed classes. SDMode-FAT will inherit from
an SDIO specific hardware class _and_ the abstract mapleFAT class. The 
SPIMode-FAT class will do the same for it's hardware specific functions and 
both XXXMode-FAT classes will have the same public calls so users can simply 
change the object instantiation line in their code to switch modes (at compile 
time).

As mentioned, mapleFAT should have definitions for all it's user visible 
functions, but it's low-level IO calls (like read and write) should be purely 
virtual. This should ensure that HardwareXXX classes define these basic 
methods: eg. virtual mapleFAT::write(where, what) = 0.

At this point you might be wondering how to separate SD card commands from the 
FAT library. Well for one, HardwareSDIO should handle that by itself. The 
peripheral is designed to handle command and response formatting and parsing.
The SPI peripheral, on the other hand, does not. HardwareSPI is a simple 
wrapper for common settings and basic byte reads so the SPIMode-FAT will have 
to provide higher-level functionality for these calls. The ultimate goal of 
this class being block read and write functions.

Future Work
-----------

This brings us to a design decision. Some commands available in SPI mode are 
not available in SD mode and vice versa. Furthermore, responses are not 
formatted the same way and some response bits are left off entirely. I'm 
proposing that the higher-level classes handle these cases.